/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "operations.h"
#include <dirent.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
 extern int err;
extern char *strdup();




char *
auth_1_svc(name *argp, struct svc_req *rqstp)
{
	  static char  result;
  
	  char *username= malloc((200)*(sizeof(char)));
    strcat(username,argp->old);
    //printf("%s\n", username);
    strcat(username," ");
    strcat(username, argp->final);
    //printf("%s\n",username );
    FILE *fp; 
    fp = fopen("username.txt", "r");
    if(fp!=NULL)
    {

        char line[200]; 
        char check[200]; 
        while( fgets ( line, sizeof(line), fp ) != NULL ) /* read a line */ 
        {
            sprintf ( check, line, 120 ); /* write the line */
            //printf("%s",check);
            int len, i, count, m, match, j; 
            len= strlen(username);
            m= strlen(check);
            count= 0;
            for(i=0; i<len; i++)
            {             
                if (username[i]==check[i])
                    count++; 
                               // matching the characters of the pattern in the text
                else
                  break;
            }
            if(count==len)
                {            
                                  //checking if all the charaters of the pattern have been matched 
                   result= 'y';
                   return &result;
                }
            
            
        }
    

    fclose ( fp ); 
    }  
  result= 'n';
	return &result;
}

char *
rename_1_svc(name *argp, struct svc_req *rqstp)
{
	static char  result;

	int i;
    
    char *str= malloc((100)*(sizeof(char)));
    sprintf(str, "sudo mv ");
    strcat(str, argp->old); strcat(str," "); strcat(str, argp->final);
    i= system(str);
    printf("%s",str);
    if(i== -1)
    	result= 'n';
    result= 'y';

	return &result;
}


char *
delete_1_svc(nametype *argp, struct svc_req *rqstp)
{
	static char  result;

	int i, len;
    
    char *str= malloc((50)*(sizeof(char)));
    sprintf(str, "sudo rm -rf ");
    strcat(str, *argp);
    i= system(str);
    if(i== -1)
    	result= 'n';
    result= 'y';

	return &result;
}


char *
move_1_svc(name *argp, struct svc_req *rqstp)
{
	static char  result;

	int i;
    char *str= malloc((100)*(sizeof(char)));
    sprintf(str, "sudo mv ");
    strcat(str, argp->old); strcat(str, " "); strcat(str, argp->final);
    i= system(str);
    printf("%s",str);
    if(i== -1)
    	result= 'n';
    result= 'y';

	return &result;
}

char *
changemode_1_svc(nametype *argp, struct svc_req *rqstp)
{
	static char  result;

	int i, len;
    
    char *str= malloc((50)*(sizeof(char)));
    sprintf(str, "chmod ");
    strcat(str, *argp);
    i= system(str);
    /*things to check
	-->system c programming output to get the error message when trying to access a different user file
	--->getting the name of the owner and group of the file within RPC protocol
	-->client server model to access file with different owners
    */
    if(i== -1)
    	result= 'n';
    result= 'y';

	return &result;
}

readdir_res *
readdir_1_svc(nametype *dirname, struct svc_req *req)

{
  DIR *dirp;
  struct dirent *d;
  namelist nl;
  namelist *nlp;

  static readdir_res res; /* must be static! */

  /* Open directory */
  dirp = opendir(*dirname);

 if (dirp == (DIR *)NULL) {
    res.err = err;
   return (&res);
  }

  /* Free previous result */
  xdr_free((xdrproc_t)xdr_readdir_res, (char *)&res);

  nlp = &res.readdir_res_u.list;
  while (d = readdir(dirp)){
    nl = *nlp = (namenode *)malloc(sizeof(namenode));
    if (nl == (namenode *) NULL){
      res.err = EAGAIN;
      closedir(dirp);
      return(&res);
    }
    nl->name = strdup(d->d_name);
    nlp = &nl->next;
  }

  *nlp = (namelist)NULL;

  /* Return the result */
  res.err = 0;
  closedir(dirp);
  return (&res);
}
